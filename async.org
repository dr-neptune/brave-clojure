#+TITLE: Mastering Concurrent Processes with core.async

Clojure's core.async library allows you to create multiple independent processes within a single program.

In this chapter, we will learn to use channels to communicate between independent processes created by go blocks and thread, a bit about how Clojure manages threads efficiently with parking and blocking, how to use alts!!, a more straight forward way to creating queues, and how to use process pipelines.

* Getting Started with Processes

At the heart of core.async is the process, a concurrently running unit of logic that responds to events.

#+BEGIN_SRC clojure
;; create a channel called echo-chan
(def echo-chan (chan))
;; create a new process
(go (println (<! echo-chan))) ;; when I take a message from echo-chan, print it
;; put the string "ketchup" on echo-chan & return true
(>!! echo-chan "ketchup")
#+END_SRC

We used the chan function to create a channel called echo-chan. Channels communicate messages. You can put messages on a channel and take messages off of a channel. Processes wait for the completion of put and take -- these are the events that processes respond to.

We can think of processes as having two rules:
1. When trying to put a message on a channel or take a message off of it, wait and do nothing until the put or take succeeds
2. When the put or take succeeds, continue executing

In the second line we used go to create a new process. Everything within the go expression (called a go block) - runs concurrently on a separate thread. Go blocks run your processes on a thread pool that contains a number of threads equal to 2 plus the number of cores on the machine. This means our program doesn't have to create a new thread for each process, so we avoid the overhead of creating threads. 

In the expression (<! echo-chan), <! is the take function. It listens to the channel you give it as an argument, and the process it belongs to waits until another process puts a message on the channel. When <! retrieves a value, the value is returned and the println expression is executed.

The expression >!! echo-chan "ketchup" puts the string "ketchup" on echo-chan and returns true. When we put the message on a channel, the process blocks until another process takes the message. 

** Buffering

Its worth noting that our last part had 2 processes: the one created with go and the REPL. The one created with go waits for something to respond to.

#+BEGIN_SRC clojure
(def echo-buffer (chan 2))
(>!! echo-buffer "ketchup")
(>!! echo-buffer "ketchup")
(>!! echo-buffer "ketchup")
#+END_SRC

In this case, we've created a channel with buffer size 2. This means that we can put two values on the channel without waiting, but putting a 3rd one on means the process will wait until another process takes a value from the channel. 

We can also create sliding buffers with sliding-buffer, which drops values in a first in first out fashion, and dropping buffers with dropping-buffer which discards values in a last-in, first out fashion. Neither of these style of buffers will ever cause >!! to block.

Buffers are just elaborations of the core model: processes are independent, concurrently executing units of logic that respond to events. You create processes with go blocks and communicate events over channels.

** Blocking and Parking

Earlier we used the take function with 1 !, >! and the put function with 2 !, >!!. We use 1 ! inside go blocks, and 2 outside of them. 

|      | Inside go block | Outside go block |
|------+-----------------+------------------|
| put  | >! or >!!       | >!!              |
| take | <! or <!!       | <!!              |

Because go blocks use a thread pool with a fixed size, you can create 1000 go processes but only a handful of threads:

#+BEGIN_SRC clojure
(def hi-chan (chan))

(doseq [n (range 1000)]
  (go (>! hi-chan (str "Hi " n))))
#+END_SRC

To understand how clojure accomplishes this we need to explore how processes wait. Waiting is a key aspect of working with core.async processes: we've already established that put waits until another process does a take on the same channel, and vice versa. In this example above, 1000 processes are waiting for another process to take from hi-chan.

There are two varieties of waiting: parking and blocking. Blocking is when a thread stops execution until a task is complete. Usually this happens when we are doing some kind of I/O operation. The thread remains alive but doesn't do any work, so we have to create a new thread (with future) if we want the program to continue working. 

Parking frees up the thread so it can keep doing work. Let's say we have 1 thread and 2 processes, pA and pB. pA is running on the thread and then waits for a put or take. Clojure moves pA off the thread and moves pB onto the thread. If pB starts waiting and pA's put or take has finished, the CLojure will move pB off the thread and put pA back on it. Parking allows the instructions for multiple processes to interleave on a single thread, similar to the way that using multiple threads allows interleaving on a single core. Parking is only possible within go blocks, and its only possible when we use >! or <!, or parking put and parking take (not >!!, <!! which are blocking put and blocking take).

** Thread 

There are times when we will want blocking rather than parking (like when the process will take a long time before putting or taking), and for these occasions we can use thread: 

#+BEGIN_SRC clojure
(thread (println (<!! echo-chan)))
(>!! echo-chan "mustard")
#+END_SRC

thread acts almost exactly like future: it creates a new thread and executes a process on that thread. Unlike future, instead of returning an object that you can dereference, thread returns a channel. When thread's process stops, the process's return value is put on a channel that thread returns

#+BEGIN_SRC clojure
(let [t (thread "Chili")]
  (<!! t))
#+END_SRC

